require "card.rb"

class Hand

	include Comparable

	# This class represents a poker hand. It's value is an array containing a poker
	# value and and array of "comparison" values. For example, if a player has two
	# pairs it will return an array of [:two_pairs, [<larger_pair_card_value>, 
	# <smaller_pair_card_value>, <high_card_value>,]]

	HANDS = {
		:high           => 0,
		:pair           => 1,
		:two_pairs      => 2,
		:three          => 3,
		:straight       => 4,
		:flush          => 5,
		:full_house     => 6,
		:four           => 7,
		:straight_flush => 8,
	}

	HAND_NAMES = {
		0 => "High card "
		1 => "Pair of "
		2 => "Two pairs of "
		3 => "Three "
		4 => ""
		5 => "Flush of"
		6 => "Full house of"
		7 => "Four "
		8 => "Straight flush of "
	}

	def initialize(cards)
		raise ArgumentError, "Argument must be an array of Cards" unless
			cards.all? { |card| card.instance_of?(Card) }
		@cards = cards.sort
		@values = {}

		# Iterate trough the cards and find pairs, threes etc.
		@cards.each do |card|
			if @values.key?(card.value)
				@values[card.value] += 1
			elsif
				@values[card.value] = 1
			end
		end

		@hand = self.calculate_hand
	end

	def highest
		@cards.max.value
	end

	attr_reader :cards, :hand 

	def calculate_hand
		# First try straight-like hands.
		if self.has_straight?
			if self.has_flush?
				return [HANDS[:straight_flush], [self.highest]]
			end
			return [HANDS[:straight], [self.highest]]
		end


		# Fours
		return [HANDS[:four], @values.key(4), @values.key(1)] if @values.has_value?(4)

		# Full house and three of a kind
		if @values.has_value?(3)
			if @values.has_value?(2)
				return [HANDS[:full_house], [@values.key(3), @values.key(2)]]
			end
			highs = @values.select { |k, v| v == 1}.keys.sort
			return [HANDS[:three], [@values.key(3), highs[1], highs[0]]]
		end

		# Flush
		if self.has_flush?
			highs = @cards.map { |card| card.value }.reverse
			return [HANDS[:flush], highs]
		end

		#Two Pairs and pair
		if @values.has_value?(2)
			if @values.select { |key, value| value == 2 }.length == 2
				pairs = @values.select {|key, value| value == 2}.keys.sort
				return [HANDS[:two_pairs], [pairs[1], pairs[0], @values.key(1)]]
			end
			highs = @values.select { |k, v| v == 1 }.keys.sort
			return [HANDS[:pair], [@values.key(2), highs[2], highs[1], highs[0]]]
		end

		# High card
		highs = @cards.map { |card| card.value }.reverse
		return [HANDS[:high], highs]

	end

	def has_straight?
		# If each value is larger by one than the preceding value.
		@cards.each_cons(2) { |a| return false if a[1].value - a[0].value != 1 }
		true
	end

	def has_flush?
		# If all cards are the same suit than the first.
		suit_test = @cards.first.suit
		@cards.all? { |card| card.suit == suit_test }
	end

	def ==(other)
		if other.instance_of(Hand)
			@hand[0] == other.hand[0] and @hand[1] == other.hand[1]
		else
			false
		end
	end

	def <=>(other)
		return nil unless other.instance_of?(Hand)
		@hand <=> other.hand
	end

	def to_s
		case @hand[0]
		when 0
			return "High card "
		end
	end
end
