class Integer

	# Returns all prime number up to n using sieve of Erastothenes.
	def generate_primes

		# There are no primes below 2.
		return nil if self < 2
		# Create a sieve with all values prime by default.
		sieve  = Array.new((self + 1) / 2 - 1) { |i| true }
		primes = [2]

		# Only test odd numbers
		(3..Math.sqrt(self)).step(2) do |n|
			if sieve[n / 2 - 1]
				(n..self/n).step(2) do |i|
					sieve[n*i/2-1] = false
				end
			end
		end

		# Iterate over the indexes in the sieve and add indexes with value 'true' to the
		# list of primes.

		(0..(self + 1) / 2 - 2).each do |i|
			primes << (i+1) * 2 + 1 if sieve[i]
		end
		primes
	end

	# This is based on the assumtion that a the n'th prime number will always
	# be less than n ln n + n ln ln n (see. Prime number theorem)
	# Basically it creates a rough estimate on the value of the n'th prime
	# number (estimate is always > than n'th prime) and then uses the Sieve of
	# erastothenes to generate primes up to that integer.
	def nth_prime
		n = self
		primes = (n * Math.log(n) + 
			  n * Math.log(Math.log(n))).to_i.generate_primes
		primes[self-1]
	end


	# Returns an array of an positive integers prime factors.
	def prime_factors(primes)
		# Numbers below 4 don't have prime factors.
		return nil if self < 4

		factors, n, max = [], self, Math.sqrt(self)

		primes.each { |prime|
			break if prime > max
			if (n % prime).zero?
				factors << prime
				n /= prime while (n % prime).zero?
				max = n
			end
		}

		factors.empty? ? nil : factors
	end

	# Returns an array of all fibonacci numbers <= n.
	def fibs
		i, j, tmp, fibs, = 0, 1, 0, [0]
		while j <= self
			fibs << j
			tmp = i + j
			i = j
			j = tmp
		end
		fibs
	end

	# Returns true if the integer is a palindrome.
	def palindrome?
		self.to_s.reverse == self.to_s
	end

	# Returns the number of divisors that a positive integer has.
	def number_of_divisors
		n, divisors = self, 2
		sqrtn = Math.sqrt(n)
		for i in 2..sqrtn
			divisors += 2 if n % i == 0
		end
		divisors -= 1 if n % sqrtn == 0
		divisors
	end

	def divisors
		n, divisors = self, []
		sqrtn = Math.sqrt(n)
		for i in 2..sqrtn
			divisors << i if (n % i).zero?
		end
		divisors
	end

	def sum_of_divisors
		return 1 if self == 1
		n, sum_divisors = self, 1
		sqrtn = Math.sqrt(n)
		for i in 2..sqrtn
			sum_divisors += (i + n/i) if n % i == 0
		end
		sum_divisors -= sqrtn if n % sqrtn == 0
		sum_divisors.to_i
	end

	# Returns the n'th triangle number, ie. 5th triangle number is 1+2+3+4+5.
	def nth_triangle_number
		(1..self).to_a.sum
	end

	def collatz
		n = self
		iterations = 1
		until n == 1
			if n.even?
				n /= 2
			else
				n = 3*n + 1
			end
			iterations += 1
		end
		iterations
	end

	# Returns the sum of the digits in a number, eg. for 12 it's 1+2=3
	def sum_digits
		self.to_s.split(//).map { |digit| digit.to_i }.sum
	end

	# Returns a string representation of the number (only for 1-1000)
	def as_text
		words = { 0 => "", 1 => "one", 2 => "two", 3 => "three", 4 => "four",
			5 => "five", 6 => "six", 7 => "seven", 8 => "eight", 9 => "nine",
			10 => "ten", 11 => "eleven", 12 => "twelve", 13 => "thirteen",
			14 => "fourteen", 15 => "fifteen", 16 => "sixteen", 17 => "seventeen",
			18 => "eighteen", 19 => "nineteen", 20 => "twenty", 30 => "thirty",
			40 => "forty", 50 => "fifty", 60 => "sixty", 70 => "seventy",
			80 => "eighty", 90 => "ninety", 100 => "hundred", 1000 => "onethousand" }

		# 1-20
		return words[self] if self <= 20 or self == 1000
		# 21-99
		return words[self-self%10] + words[self%10] if self < 100
		# Hundreds
		return words[self/100] + words[100] if (self % 100).zero?
		# Hundreds + 1-20
		return words[self/100] + words[100] + "and" + words[self % 100] if (self % 100) < 20
		# Hundreds + 21-99
		return words[self/100] + words[100] + "and" + words[self % 100 - self % 10] + words[self%10]
	end

	def factorial
		return 1 if self.zero?
		self * (self-1).factorial
	end

	def decimal_cycle_length
		divisions, n, length =  {}, 10, 0
		until divisions.key?(n % self)
			divisions[n % self] = true
			n, length = (n % self) * 10, length += 1
		end
		length
	end

	# Returns true if value is prime
	def prime?
		# First test if it's divisible by a few common primes, or it's < 2
		return false if [2,3,5].any? { |n| (self % n).zero? and self != n }
		# Then test divide by good prime candidates in form 6k +- 1
		(6..Math.sqrt(self).ceil.to_i).step(6) do |n|
			return false if (self % (n+1)).zero? or (self % (n-1)).zero?
		end
		true # If it wasn't divisible by any number tested
	end

	# Rotates an integer
	def rotate
		return self if self < 10
		part = self.to_s[-1,1]
		(part + self.to_s.chop).to_i
	end

	# Returns an array of the rotations
	def rotations
		circus, n = [], self
		(1..self.to_s.length).each { |rotation|
			n = n.rotate
			circus << n
		}
		circus
	end

	# Returns an array of the digits
	def to_a
		array = []
		self.to_s.each_char { |digit| array << digit.to_i }
		array
	end

	# True if n, multiplier and the product are pandigital
	def ppandig?(multiplier)
		n = self * multiplier
		((1..9).to_a - (self.to_a + multiplier.to_a + n.to_a)).length.zero?
	end

	def pandigital?
		((1..self.to_s.length).to_a - (self.to_a)).length.zero?
	end

	# Returns the binary representation of the integer.
	def to_b
		n, binary = self, ""
		until n.zero?
			binary << (n % 2).to_s
			n /= 2
		end
		binary
	end

	def truncl
		n, array = self.to_s, []
		while n.sub!(/./, "").length > 0
			array << n.to_i
		end
		array
	end

	def truncr
		n, array = self.to_s, []
		while n.chop!.length > 0
			array << n.to_i
		end
		array
	end

	def triangles
		array, n, triangle = [], 1, 0
		until triangle >= self
			triangle = (0.5 * n * (n + 1)).to_i
			array << triangle
			n += 1
		end
		array
	end

	def pentagonal
		self * (3 * self - 1) / 2
	end

	def pentagonal?
		n = (Math.sqrt(24*self + 1) + 1) / 6
		n - n.to_i == 0
	end

	def lychrel?
		n = self
		50.times do |i|
			n += n.to_s.reverse.to_i
			return false if n.palindrome?
		end
		true
	end

	def choose(k)
		self.factorial / (k.factorial * (self - k).factorial)
	end

	def length
		(Math.log10(self) + 1).to_i
	end

end

class Array
	# Returns the sum of the elements in an array.
	def sum
		self.inject { |sum, i| sum += i }
	end

	# Returns the product of the elements in an array.
	def prod
		self.inject(1) { |product, i| product *= i }
	end

	def to_h
		hash = { }
		self.each { |value| hash[value] = value }
		hash
	end

	# Returns the next lexicographic permutation of an array.
	def next_permutation
		return self if self.length < 2

		pivot = self.length - 2
		successor = pivot + 1
		while pivot >= 0
			break if self[pivot] < self[pivot+1]
			pivot -= 1
		end
		return self.reverse! if pivot < 0

		(successor).downto(0) do |i|
			successor = i
			break if self[successor] > self[pivot]
		end

		# Swap pivot and successor
		self[pivot], self[successor] = self[successor], self[pivot]
		pivot += 1
		# Reverse the rest of the array
		self[pivot..self.length-1] = self[pivot..self.length-1].reverse
		self
	end

	def permutations
		perms, n = [], self.dup
		n = n.dup.next_permutation
		until n == self
			perms << n
			n = n.dup.next_permutation
		end
		perms
	end

end

class String

	# Returns the alphabetical value of a string, eg. the sum of alphabetical
	# positions of each letter.
	def alphabetical_position
		alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
		sum = 0
		self.each_byte { |letter| sum +=  alphabet.index(letter) + 1 }
		sum
	end

	def palindrome?
		self.reverse == self
	end

end
